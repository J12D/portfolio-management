}
# Calculate #loops
loops <- risk.premium.up / risk.increment + 1
loop <- 1
# Initialize a matrix to contain allocation and statistics
eff <- matrix(nrow = loops, ncol = n + 3)
# Now I need to give the matrix column names
colnames(eff) <- c(colnames(returns), "Std.Dev", "Exp.Return", "sharpe")
# Loop through the quadratic program solver
for (i in seq(from = 0, to = risk.premium.up, by = risk.increment)) {
dvec <- colMeans(returns) * i # This moves the solution along the EF
sol <- solve.QP(covmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = meq)
eff[loop, "Std.Dev"] <- sqrt(sum(sol$solution * colSums((covmat * sol$solution))))
eff[loop, "Exp.Return"] <- as.numeric(sol$solution %*% colMeans(returns))
eff[loop, "sharpe"] <- eff[loop,"Exp.Return"] / eff[loop,"Std.Dev"]
eff[loop, 1:n] <- sol$solution
loop <- loop + 1
}
eff <- as.data.frame(eff)
eff <- eff[eff$sharpe == max(eff$sharpe),]
rownames(eff) <- NULL
return(eff$sharpe)
}
covmat <- cov(returns)
eff <- eff.frontier(returns, covmat, short = "yes", max.allocation = 0.5,
risk.premium.up = 5, risk.increment = .01)
eff
#http://economistatlarge.com/portfolio-theory/r-optimized-portfolio
library(quadprog)
eff.frontier <- function(returns, covmat, short, max.allocation,
risk.premium.up, risk.increment){
n <- ncol(covmat)
# Create Amat & bvec assuming only equality constraint, short-selling allowed, no allocation constraints
Amat <- matrix(1, nrow=n)
bvec <- 1
meq <- 1
# Modify Amat & bvec if short-selling not allowed
if (short == "no") {
Amat <- cbind(1, diag(n))
bvec <- c(bvec, rep(0, n))
}
# Modify Amat & bvec for max allocation constraint
if (!is.null(max.allocation)) {
if (max.allocation > 1 | max.allocation < 0) {
stop("max.allocation must be greater than 0 and less than 1")
}
if (max.allocation * n < 1) {
stop("Need to set max.allocation higher; not enough assets to add to 1")
}
Amat <- cbind(Amat, -diag(n))
bvec <- c(bvec, rep(-max.allocation, n))
}
# Calculate #loops
loops <- risk.premium.up / risk.increment + 1
loop <- 1
# Initialize a matrix to contain allocation and statistics
eff <- matrix(nrow = loops, ncol = n + 3)
# Now I need to give the matrix column names
colnames(eff) <- c(colnames(returns), "Std.Dev", "Exp.Return", "sharpe")
# Loop through the quadratic program solver
for (i in seq(from = 0, to = risk.premium.up, by = risk.increment)) {
dvec <- colMeans(returns) * i # This moves the solution along the EF
sol <- solve.QP(covmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = meq)
eff[loop, "Std.Dev"] <- sqrt(sum(sol$solution * colSums((covmat * sol$solution))))
eff[loop, "Exp.Return"] <- as.numeric(sol$solution %*% colMeans(returns))
eff[loop, "sharpe"] <- eff[loop,"Exp.Return"] / eff[loop,"Std.Dev"]
eff[loop, 1:n] <- sol$solution
loop <- loop + 1
}
eff <- as.data.frame(eff)
eff <- eff[eff$sharpe == max(eff$sharpe),]
rownames(eff) <- NULL
eff <- foo[,c("DAX", "Dow Jones", ...)]
return(eff)
}
covmat <- cov(returns)
eff <- eff.frontier(returns, covmat, short = "yes", max.allocation = 0.5,
risk.premium.up = 5, risk.increment = .01)
eff
#http://economistatlarge.com/portfolio-theory/r-optimized-portfolio
library(quadprog)
eff.frontier <- function(returns, covmat, short, max.allocation,
risk.premium.up, risk.increment){
n <- ncol(covmat)
# Create Amat & bvec assuming only equality constraint, short-selling allowed, no allocation constraints
Amat <- matrix(1, nrow=n)
bvec <- 1
meq <- 1
# Modify Amat & bvec if short-selling not allowed
if (short == "no") {
Amat <- cbind(1, diag(n))
bvec <- c(bvec, rep(0, n))
}
# Modify Amat & bvec for max allocation constraint
if (!is.null(max.allocation)) {
if (max.allocation > 1 | max.allocation < 0) {
stop("max.allocation must be greater than 0 and less than 1")
}
if (max.allocation * n < 1) {
stop("Need to set max.allocation higher; not enough assets to add to 1")
}
Amat <- cbind(Amat, -diag(n))
bvec <- c(bvec, rep(-max.allocation, n))
}
# Calculate #loops
loops <- risk.premium.up / risk.increment + 1
loop <- 1
# Initialize a matrix to contain allocation and statistics
eff <- matrix(nrow = loops, ncol = n + 3)
# Now I need to give the matrix column names
colnames(eff) <- c(colnames(returns), "Std.Dev", "Exp.Return", "sharpe")
# Loop through the quadratic program solver
for (i in seq(from = 0, to = risk.premium.up, by = risk.increment)) {
dvec <- colMeans(returns) * i # This moves the solution along the EF
sol <- solve.QP(covmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = meq)
eff[loop, "Std.Dev"] <- sqrt(sum(sol$solution * colSums((covmat * sol$solution))))
eff[loop, "Exp.Return"] <- as.numeric(sol$solution %*% colMeans(returns))
eff[loop, "sharpe"] <- eff[loop,"Exp.Return"] / eff[loop,"Std.Dev"]
eff[loop, 1:n] <- sol$solution
loop <- loop + 1
}
eff <- as.data.frame(eff)
eff <- eff[eff$sharpe == max(eff$sharpe),]
rownames(eff) <- NULL
eff <- foo[,c("DAX", "Dow Jones", "Nikkei", "VIX")]
return(eff)
}
covmat <- cov(returns)
eff <- eff.frontier(returns, covmat, short = "yes", max.allocation = 0.5,
risk.premium.up = 5, risk.increment = .01)
eff
#http://economistatlarge.com/portfolio-theory/r-optimized-portfolio
library(quadprog)
eff.frontier <- function(returns, covmat, short, max.allocation,
risk.premium.up, risk.increment){
n <- ncol(covmat)
# Create Amat & bvec assuming only equality constraint, short-selling allowed, no allocation constraints
Amat <- matrix(1, nrow=n)
bvec <- 1
meq <- 1
# Modify Amat & bvec if short-selling not allowed
if (short == "no") {
Amat <- cbind(1, diag(n))
bvec <- c(bvec, rep(0, n))
}
# Modify Amat & bvec for max allocation constraint
if (!is.null(max.allocation)) {
if (max.allocation > 1 | max.allocation < 0) {
stop("max.allocation must be greater than 0 and less than 1")
}
if (max.allocation * n < 1) {
stop("Need to set max.allocation higher; not enough assets to add to 1")
}
Amat <- cbind(Amat, -diag(n))
bvec <- c(bvec, rep(-max.allocation, n))
}
# Calculate #loops
loops <- risk.premium.up / risk.increment + 1
loop <- 1
# Initialize a matrix to contain allocation and statistics
eff <- matrix(nrow = loops, ncol = n + 3)
# Now I need to give the matrix column names
colnames(eff) <- c(colnames(returns), "Std.Dev", "Exp.Return", "sharpe")
# Loop through the quadratic program solver
for (i in seq(from = 0, to = risk.premium.up, by = risk.increment)) {
dvec <- colMeans(returns) * i # This moves the solution along the EF
sol <- solve.QP(covmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = meq)
eff[loop, "Std.Dev"] <- sqrt(sum(sol$solution * colSums((covmat * sol$solution))))
eff[loop, "Exp.Return"] <- as.numeric(sol$solution %*% colMeans(returns))
eff[loop, "sharpe"] <- eff[loop,"Exp.Return"] / eff[loop,"Std.Dev"]
eff[loop, 1:n] <- sol$solution
loop <- loop + 1
}
eff <- as.data.frame(eff)
eff <- eff[eff$sharpe == max(eff$sharpe),]
rownames(eff) <- NULL
return(eff)
}
covmat <- cov(returns)
eff <- eff.frontier(returns, covmat, short = "yes", max.allocation = 0.5,
risk.premium.up = 5, risk.increment = .01)
eff
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
# convenience function for ggploting xts objects
plotXTS <- function(xtsObject, title, xlab = "time", ylab = "value", size = 0.5){
d <- data.frame(time = index(xtsObject), value = drop(coredata(xtsObject)))
if (dim(xtsObject)[2]) {
d <- melt(d, id.vars = "time", varnames = names(dimnames(xtsObject)))
}
res_plot <- ggplot(d, aes(time, value)) +
xlab(xlab) +
ylab(ylab) +
scale_colour_hue() +
theme(plot.title = element_text(lineheight = .8, face = "bold"), text = element_text(size = 14))
if (dim(xtsObject)[2] > 1) {
res_plot <- res_plot + geom_line(aes(colour = variable), size = size)
}
else {
res_plot <- res_plot + geom_line(colour = gg_color_hue(1), size = size)
}
if (!missing(title)) {
res_plot + ggtitle(title)
}
else {
res_plot
}
}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots == 1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
xts2df <- function(xts) {
stopifnot(is.xts(xts))
data.frame(time = index(xts), drop(coredata(xts)))
}
df2xts <- function(df) {
stopifnot(is.data.frame(df))
xts(df[,("time" != colnames(df))],df[,("time" == colnames(df))])
}
ones <- function(num) {
rep.int(1, num)
}
zeros <- function(num) {
rep.int(0, num)
}
calcMDD <- function(asset) {
asset <- rev(asset)
if (length(asset) < 2) return(0)
maxDiffPortVal <- as.numeric(asset[2]) - as.numeric(asset[1])
minPortVal <- as.numeric(asset[1])
for (i in 1:(length(asset))) {
if (as.numeric(asset[i]) - minPortVal > maxDiffPortVal)
{
maxDiffPortVal <- as.numeric(asset[i]) - minPortVal
}
if (as.numeric(asset[i]) < minPortVal)
{
minPortVal <- as.numeric(asset[i])
}
}
mdd <- max(0, (minPortVal + maxDiffPortVal) / minPortVal - 1) * 100
mdd
}
assets["2012-01-31/"] %>% rowSums.xts %>% apply.monthly(calcMDD) %>% mean
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
# convenience function for ggploting xts objects
plotXTS <- function(xtsObject, title, xlab = "time", ylab = "value", size = 0.5){
d <- data.frame(time = index(xtsObject), value = drop(coredata(xtsObject)))
if (dim(xtsObject)[2]) {
d <- melt(d, id.vars = "time", varnames = names(dimnames(xtsObject)))
}
res_plot <- ggplot(d, aes(time, value)) +
xlab(xlab) +
ylab(ylab) +
scale_colour_hue() +
theme(plot.title = element_text(lineheight = .8, face = "bold"), text = element_text(size = 14))
if (dim(xtsObject)[2] > 1) {
res_plot <- res_plot + geom_line(aes(colour = variable), size = size)
}
else {
res_plot <- res_plot + geom_line(colour = gg_color_hue(1), size = size)
}
if (!missing(title)) {
res_plot + ggtitle(title)
}
else {
res_plot
}
}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots == 1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
xts2df <- function(xts) {
stopifnot(is.xts(xts))
data.frame(time = index(xts), drop(coredata(xts)))
}
df2xts <- function(df) {
stopifnot(is.data.frame(df))
xts(df[,("time" != colnames(df))],df[,("time" == colnames(df))])
}
ones <- function(num) {
rep.int(1, num)
}
zeros <- function(num) {
rep.int(0, num)
}
calcMDD <- function(asset) {
asset <- rev(asset)
if (length(asset) < 2) return(0)
maxDiffPortVal <- as.numeric(asset[2]) - as.numeric(asset[1])
minPortVal <- as.numeric(asset[1])
for (i in 1:(length(asset))) {
if (as.numeric(asset[i]) - minPortVal > maxDiffPortVal)
{
maxDiffPortVal <- as.numeric(asset[i]) - minPortVal
}
if (as.numeric(asset[i]) < minPortVal)
{
minPortVal <- as.numeric(asset[i])
}
}
mdd <- max(0, (minPortVal + maxDiffPortVal) / minPortVal - 1) * 100
mdd
}
assets["2012-01-31/"] %>% rowSums.xts %>% apply.monthly(calcMDD) %>% mean
calcMDD <- function(asset) {
asset <- rev(asset)
if (length(asset) < 2) return(0)
maxDiffPortVal <- as.numeric(asset[2]) - as.numeric(asset[1])
minPortVal <- as.numeric(asset[1])
for (i in 1:(length(asset))) {
if (as.numeric(asset[i]) - minPortVal > maxDiffPortVal)
{
maxDiffPortVal <- as.numeric(asset[i]) - minPortVal
}
if (as.numeric(asset[i]) < minPortVal)
{
minPortVal <- as.numeric(asset[i])
}
}
mdd <- max(0, (minPortVal + maxDiffPortVal) / minPortVal - 1) * 100
mdd
}
assets["2012-01-31/"] %>% rowSums.xts %>% apply.monthly(calcMDD) %>% mean
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
# convenience function for ggploting xts objects
plotXTS <- function(xtsObject, title, xlab = "time", ylab = "value", size = 0.5){
d <- data.frame(time = index(xtsObject), value = drop(coredata(xtsObject)))
if (dim(xtsObject)[2]) {
d <- melt(d, id.vars = "time", varnames = names(dimnames(xtsObject)))
}
res_plot <- ggplot(d, aes(time, value)) +
xlab(xlab) +
ylab(ylab) +
scale_colour_hue() +
theme(plot.title = element_text(lineheight = .8, face = "bold"), text = element_text(size = 14))
if (dim(xtsObject)[2] > 1) {
res_plot <- res_plot + geom_line(aes(colour = variable), size = size)
}
else {
res_plot <- res_plot + geom_line(colour = gg_color_hue(1), size = size)
}
if (!missing(title)) {
res_plot + ggtitle(title)
}
else {
res_plot
}
}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots == 1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
xts2df <- function(xts) {
stopifnot(is.xts(xts))
data.frame(time = index(xts), drop(coredata(xts)))
}
df2xts <- function(df) {
stopifnot(is.data.frame(df))
xts(df[,("time" != colnames(df))],df[,("time" == colnames(df))])
}
ones <- function(num) {
rep.int(1, num)
}
zeros <- function(num) {
rep.int(0, num)
}
library(magrittr)
library(quantmod)
library(Quandl)
library(lubridate)
Sys.setenv(TZ = "UTC")
# -- Indices -------------------
# getSymbols(c("^GDAXI","^DJI","^N225","VXX"),from="1995-01-01")
# -- EURIBOR -------------------
### no  euribor <- Quandl("ECB/RTD_M_S0_N_C_EUR3M_E")
# euribor <- Quandl("BOF/QS_D_IEUTIO3M")
# euribor <- xts(euribor[,-1]/100,euribor[,1])
# -- Factors -------------------
# factors <- read.csv("data/factors.csv")
# factors$X %<>% parse_date_time("%Y%m%d")
# factors <- xts(factors[,-1]/100,factors[,1])["1995/"]
# -- FX -------------------
# eurusd_0 <- getFX("EUR/USD", from = "2008-01-01", to = "2011-01-01", auto.assign = F)
# eurusd_1 <- getFX("EUR/USD", from = "2011-01-02", auto.assign = F)
# eurusd <- rbind(eurusd_0, eurusd_1)
#
# eurjpy_0 <- getFX("EUR/JPY", from = "2008-01-01", to = "2011-01-01", auto.assign = F)
# eurjpy_1 <- getFX("EUR/JPY", from = "2011-01-02", auto.assign = F)
# eurjpy <- rbind(eurjpy_0, eurjpy_1)
#
# fx <- merge.xts(eurusd, eurjpy)
# saveRDS(list(GDAXI=GDAXI, DJI=DJI, N225=N225, VXX=VXX, euribor=euribor, factors=factors, fx=fx),"data/assets")
assets <- readRDS("data/assets")
GDAXI <- assets[["GDAXI"]][,"GDAXI.Adjusted"]
DJI <- assets[["DJI"]][,"DJI.Adjusted"]
N225 <- assets[["N225"]][,"N225.Adjusted"]
VXX <- assets[["VXX"]][,"VXX.Adjusted"]
euribor <- assets[["euribor"]]/252
factors <- assets[["factors"]]
fx <- assets[["fx"]]
assets <- merge.xts(GDAXI, DJI, N225, VXX)["2009-01-30/"] %>% na.locf
colnames(assets) <- c("DAX", "Dow Jones", "Nikkei", "VIX")
asset_returns <- assets %>% ROC(type = "discrete")
returns <- asset_returns["2009-02-02/"] %>% na.omit
colnames(returns) <- c("DAX", "Dow Jones", "Nikkei", "VIX")
euribor <- euribor["2009-02-02/"] %>% na.omit
factors <- factors["2009-02-02/"] %>% na.omit
fx <- fx["2009-02-02/"]
rm(list = c("GDAXI", "DJI", "N225", "VXX", "asset_returns"))
message("> Imported data ---------------")
calcMDD <- function(asset) {
asset <- rev(asset)
if (length(asset) < 2) return(0)
maxDiffPortVal <- as.numeric(asset[2]) - as.numeric(asset[1])
minPortVal <- as.numeric(asset[1])
for (i in 1:(length(asset))) {
if (as.numeric(asset[i]) - minPortVal > maxDiffPortVal)
{
maxDiffPortVal <- as.numeric(asset[i]) - minPortVal
}
if (as.numeric(asset[i]) < minPortVal)
{
minPortVal <- as.numeric(asset[i])
}
}
mdd <- max(0, (minPortVal + maxDiffPortVal) / minPortVal - 1) * 100
mdd
}
assets["2012-01-31/"] %>% rowSums.xts %>% apply.monthly(calcMDD) %>% mean
